## System 계열
DsSystem	<-->	NjSystem	<-->	AAS (ISubmodel / System.Text.Json.Nodes.JsonObject)	<-->	AAS {Xml, Json}Document
								<-->	Newtonsoft.Json		<--> *.json
			<-->	ORMSystem   <-->	Database

## Project 계열
Project	<-->	   NjProject	<-->	AAS (ISubmodel / System.Text.Json.Nodes.JsonObject)	<-->	AAS {Xml, Json}Document
								<-->	Newtonsoft.Json		<--> *.json
			<-->	ORMProject  <-->	Database

## Work/Flow/Call 계열
동일한 3가지 타입 변환 패턴이 모든 도메인 객체에 적용됨:
- **Runtime Type**: Work, Flow, Call, ApiDef, ApiCall (메모리 실행 객체)
- **JSON Type**: NjWork, NjFlow, NjCall, NjApiDef, NjApiCall (직렬화 객체)  
- **ORM Type**: ORMWork, ORMFlow, ORMCall, ORMApiDef, ORMApiCall (DB 매핑 객체)

---

# Third Party 확장 설계

## 문제점과 요구사항

### 현재 제약사항
1. **하드코딩된 타입 체크**: `getRuntimeObject<Project>`, pattern matching에서 구체 타입 의존
2. **Static Factory 제한**: `Project.Create()`, `DsSystem.Create()` 등이 고정된 타입만 생성
3. **직렬화 타입 제한**: JSON/DB 직렬화시 `RuntimeType` 필드가 하드코딩
4. **확장성 부족**: Third Party에서 새로운 타입 추가시 Core 라이브러리 수정 필요

### 요구사항
- Core 프로젝트(Ev2.Core.FS, Ev2.Aas.FS)는 Hmc.Aas 프로젝트를 알아서는 안됨
- Third Party에서 기존 클래스를 상속한 확장 클래스 지원 필요
- 기존 코드 호환성 유지 (fallback to default)
- C# 프로젝트에서 쉽게 확장할 수 있어야 함

## 설계 원칙

### 의존성 방향
```
Third Party Extensions → Hmc.Aas → Ev2.Core.FS, Ev2.Aas.FS
                                 ↑
                         인터페이스 주입만 수행
```

### 핵심 아이디어
1. **Interface Injection Pattern**: C# friendly 인터페이스를 Core에 정의하고 구현체를 외부에서 주입
2. **Generic Helper Pattern**: 반복 코드 제거를 위한 제네릭 팩토리 함수
3. **Fallback Strategy**: 확장 타입이 없을 경우 기본 타입으로 자동 fallback

## ITypeFactory 인터페이스 설계

### Core Library에서 정의 (Ev2.Core.FS)
```fsharp
// C# 호환 인터페이스 정의
type ITypeFactory =
    abstract CreateRuntime : runtimeType:Type -> obj
    abstract CreateJson : runtimeType:Type * runtimeObj:obj -> obj  
    abstract CreateOrm : runtimeType:Type -> obj
    abstract GetJsonType : runtimeType:Type -> Type
    abstract GetOrmType : runtimeType:Type -> Type

// Global factory instance (mutable, Core에서 정의)
let mutable TypeFactory : ITypeFactory option = None
```

### 인터페이스 역할
- **CreateRuntime**: 지정된 런타임 타입의 인스턴스 생성
- **CreateJson**: 런타임 객체로부터 JSON 직렬화 객체 생성
- **CreateOrm**: 지정된 런타임 타입에 해당하는 ORM 객체 생성
- **GetJsonType**: 런타임 타입에 매핑되는 JSON 타입 해결
- **GetOrmType**: 런타임 타입에 매핑되는 ORM 타입 해결

### 확장성 보장
- 모든 타입 생성 로직이 외부 구현체에 위임됨
- Core 라이브러리는 인터페이스에만 의존
- null 반환시 기본 구현으로 fallback

## Generic Helper 함수 패턴

### 반복 코드 제거를 위한 Helper 함수
```fsharp
// Ev2.Core.FS에 추가할 generic helper
module TypeFactoryHelper =
    let createWithFallback<'T when 'T : (new : unit -> 'T)> (fallbackFactory: unit -> 'T) : 'T =
        match TypeFactory with
        | Some factory -> 
            let obj = factory.CreateRuntime(typeof<'T>)
            if obj <> null then obj :?> 'T 
            else fallbackFactory()
        | None -> fallbackFactory()

    // inline 최적화 버전
    let inline createExtensible<'T when 'T : (new : unit -> 'T)> (defaultFactory: unit -> 'T) =
        match TypeFactory with
        | Some factory -> 
            let obj = factory.CreateRuntime(typeof<'T>)
            if obj <> null then obj :?> 'T else defaultFactory()
        | None -> defaultFactory()
```

### 간소화된 Factory 메서드들
```fsharp
// 기존 static Create 메서드들의 간소화된 구현
type Project with
    static member Create() = 
        createExtensible (fun () -> Project([], []))

type DsSystem with  
    static member Create() =
        createExtensible (fun () -> DsSystem([||], [||], [||], [||], [||]))

type Work with
    static member Create() =
        createExtensible (fun () -> Work([], [], None))

type Call with
    static member Create() =
        createExtensible (fun () -> Call(DbCallType.Normal, [], [], [], false, None))

type Flow with
    static member Create() = 
        createExtensible (fun () -> Flow([], [], [], []))

type ApiDef with
    static member Create() = 
        createExtensible (fun () -> ApiDef(true))
```

### 장점
- **DRY 원칙**: 모든 Create 메서드에서 동일한 패턴 사용으로 반복 코드 완전 제거
- **타입 안전성**: Generic constraint로 컴파일 타임 체크
- **성능**: inline으로 런타임 최적화
- **일관성**: 모든 도메인 객체에서 동일한 확장 패턴
- **유지보수**: 새 타입 추가시 한 줄로 해결

## 확장 타입 등록 방법

### Hmc.Aas 프로젝트에서 구현
```csharp
// ExtensibleTypeFactory.cs
public class ExtensibleTypeFactory : ITypeFactory
{
    private readonly Dictionary<Type, Func<object>> _runtimeFactories = new();
    private readonly Dictionary<Type, Type> _jsonTypeMap = new();
    private readonly Dictionary<Type, Type> _ormTypeMap = new();
    private readonly Dictionary<Type, Func<object, object>> _jsonFactories = new();
    private readonly Dictionary<Type, Func<object>> _ormFactories = new();
    
    // Third Party 확장 타입 등록
    public void RegisterTypes<TRuntime, TJson, TOrm>()
        where TRuntime : class, new()
        where TJson : class
        where TOrm : class, new()
    {
        var runtimeType = typeof(TRuntime);
        var jsonType = typeof(TJson);
        var ormType = typeof(TOrm);
        
        // Runtime 타입 생성자 등록
        _runtimeFactories[runtimeType] = () => new TRuntime();
        
        // 타입 매핑 등록
        _jsonTypeMap[runtimeType] = jsonType;
        _ormTypeMap[runtimeType] = ormType;
        
        // JSON/ORM 생성자 등록
        _jsonFactories[runtimeType] = (runtimeObj) => 
            Activator.CreateInstance(jsonType, runtimeObj);
        _ormFactories[runtimeType] = () => new TOrm();
    }
    
    // ITypeFactory 구현
    public object CreateRuntime(Type runtimeType)
    {
        return _runtimeFactories.TryGetValue(runtimeType, out var factory) 
            ? factory() : null;
    }
    
    public object CreateJson(Type runtimeType, object runtimeObj)
    {
        return _jsonFactories.TryGetValue(runtimeType, out var factory)
            ? factory(runtimeObj) : null;
    }
    
    public object CreateOrm(Type runtimeType)
    {
        return _ormFactories.TryGetValue(runtimeType, out var factory)
            ? factory() : null;
    }
    
    public Type GetJsonType(Type runtimeType)
    {
        return _jsonTypeMap.TryGetValue(runtimeType, out var jsonType) 
            ? jsonType : null;
    }
    
    public Type GetOrmType(Type runtimeType)
    {
        return _ormTypeMap.TryGetValue(runtimeType, out var ormType) 
            ? ormType : null;
    }
}
```

### 확장 타입 초기화
```csharp
// ExtensionBootstrapper.cs
public static class ExtensionBootstrapper
{
    public static void Initialize()
    {
        var factory = new ExtensibleTypeFactory();
        
        // Core 기본 타입들 등록
        RegisterCoreTypes(factory);
        
        // Third Party 확장 타입들 등록  
        RegisterExtensionTypes(factory);
        
        // F# Core에 factory 주입
        Ev2.Core.FS.TypeFactory = factory;
    }
    
    private static void RegisterCoreTypes(ExtensibleTypeFactory factory)
    {
        factory.RegisterTypes<Project, NjProject, ORMProject>();
        factory.RegisterTypes<DsSystem, NjSystem, ORMSystem>();
        factory.RegisterTypes<Work, NjWork, ORMWork>();
        factory.RegisterTypes<Flow, NjFlow, ORMFlow>();
        factory.RegisterTypes<Call, NjCall, ORMCall>();
        factory.RegisterTypes<ApiDef, NjApiDef, ORMApiDef>();
        factory.RegisterTypes<ApiCall, NjApiCall, ORMApiCall>();
    }
    
    private static void RegisterExtensionTypes(ExtensibleTypeFactory factory)
    {
        // Third Party 확장 예시
        factory.RegisterTypes<CustomProject, CustomNjProject, CustomORMProject>();
        factory.RegisterTypes<CustomSystem, CustomNjSystem, CustomORMSystem>();
        factory.RegisterTypes<AdvancedWork, AdvancedNjWork, AdvancedORMWork>();
    }
}
```

### Third Party 확장 클래스 예시
```csharp
// Third Party에서 정의하는 확장 클래스들
public class CustomProject : Project
{
    public string CustomProperty { get; set; }
    public CustomProject() : base(new List<DsSystem>(), new List<DsSystem>()) { }
}

public class CustomNjProject : NjProject
{
    public string CustomProperty { get; set; }
    public CustomNjProject() { }
}

public class CustomORMProject : ORMProject
{
    public string CustomProperty { get; set; }
    public CustomORMProject() { }
}
```

## 사용 시나리오와 워크플로우

### 1. 애플리케이션 시작시 초기화
```csharp
// Program.cs 또는 애플리케이션 entry point
class Program
{
    static void Main(string[] args)
    {
        // Third Party 확장 지원 초기화
        ExtensionBootstrapper.Initialize();
        
        // 이후 모든 Core 라이브러리 호출에서 확장 타입 자동 사용
        var project = Project.Create(); // CustomProject 인스턴스 생성됨
        var system = DsSystem.Create(); // CustomSystem 인스턴스 생성됨
    }
}
```

### 2. JSON 직렬화/역직렬화에서 확장 지원
- **기존**: `project.ToJson()` → NjProject 사용
- **확장 후**: `project.ToJson()` → CustomNjProject 사용 (자동)
- **fallback**: 확장 타입 없으면 기본 NjProject 사용

### 3. 데이터베이스 ORM에서 확장 지원
- **기존**: DB 저장시 ORMProject 사용
- **확장 후**: CustomORMProject 사용 (자동)
- **추가 필드**: CustomProperty 자동으로 DB 스키마에 포함

## 아키텍처 다이어그램

### 전체 시스템 구조
```
┌─────────────────────────────────────────────────────────────┐
│                    Third Party Extensions                   │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   CustomProject │  │   CustomSystem  │  │  CustomWork  │ │
│  │   CustomNjProject│  │  CustomNjSystem │  │ CustomNjWork │ │
│  │  CustomORMProject│  │ CustomORMSystem │  │CustomORMWork │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                  │
                                  ▼ RegisterTypes()
┌─────────────────────────────────────────────────────────────┐
│                        Hmc.Aas                             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              ExtensibleTypeFactory                     │ │
│  │  - RegisterTypes<TRuntime, TJson, TOrm>()             │ │
│  │  - CreateRuntime(Type) → obj                          │ │
│  │  - CreateJson(Type, obj) → obj                        │ │
│  │  - CreateOrm(Type) → obj                              │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                  │
                                  ▼ Interface Injection
┌─────────────────────────────────────────────────────────────┐
│                    Ev2.Core.FS                             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                ITypeFactory                           │ │
│  │  + CreateRuntime(Type) → obj                          │ │
│  │  + CreateJson(Type, obj) → obj                        │ │
│  │  + CreateOrm(Type) → obj                              │ │
│  └─────────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              TypeFactoryHelper                        │ │
│  │  - createExtensible<'T>(fallback) → 'T               │ │
│  └─────────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │          Core Domain Classes                           │ │
│  │  Project.Create() → createExtensible(...)             │ │
│  │  DsSystem.Create() → createExtensible(...)            │ │
│  │  Work.Create() → createExtensible(...)                │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                  │
                                  ▼ Uses
┌─────────────────────────────────────────────────────────────┐
│                    Ev2.Aas.FS                              │
│  - AAS XML/JSON 직렬화                                      │
│  - AASX 파일 처리                                           │
│  - 확장 타입 지원 (자동)                                     │
└─────────────────────────────────────────────────────────────┘
```

### 확장성 보장 메커니즘
1. **Interface Segregation**: Core는 인터페이스에만 의존
2. **Dependency Injection**: 구현체는 외부에서 주입
3. **Fallback Strategy**: 확장 없어도 기본 동작 보장
4. **Type Safety**: Generic constraint로 컴파일 타임 안전성
5. **Zero Breaking Changes**: 기존 코드 수정 불필요