# DS Duality 이중성 개요

## 1. 개요

DS(Dualsoft) 시스템은 복잡한 산업 자동화 환경에서 유연하고 확장 가능한 시스템 설계를 위해 **이중성(Duality)** 개념을 핵심 설계 원리로 채택합니다. 이중성이란 **하나의 구성 요소가 맥락에 따라 역할과 의미가 달라지는 설계 구조**로, 모듈화 및 재사용성, 시스템 간 연결성, 동적 해석 가능성을 극대화합니다.

이중성은 크게 두 가지 범주로 나뉩니다:

- **구조적 이중성 (Structural Duality)**: 시스템 구성 요소 간의 설계 및 역할 분리와 관계
- **실행적 이중성 (Execution Duality)**: 실행 시점에서의 상태 변화, 신호 감지, 인과 흐름의 해석

---

## 2. 이중성의 핵심 원리

1. **동적 역할 전환**: 동일한 객체라도 호출 방향, 관찰 관점, 흐름 조건에 따라 다른 역할 수행
2. **관계 기반 해석**: 객체 자체보다 인과 연결(Arrow)과 주변 관계에 따라 해석
3. **계층적 추상화**: Bit → Call → Work → System → Project 구조로 확장
4. **반복 가능한 흐름 구조**: `ApiDef → Work → Call → ApiCall → ApiDef → ...` 구조가 순환됨

---

## 3. 구조적 이중성 요약 (Cases 1–4)

| Case | 구성 요소                | 이중성 설명                                  |
|------|-------------------------|----------------------------------------------|
| 1    | System ⊕ Device         | 호출 방향에 따라 능동적/수동적 역할 수행           |
| 2    | Instance ⊕ Reference    | 실행 실체와 참조 대상을 구분하며 설계-사용 분리        |
| 3    | 원인(Bit) ⊕ 결과(Bit)   | Bit는 흐름 속에서 원인이자 결과로 해석됨             |
| 4    | ReadTag ⊕ WriteTag      | 호출자와 응답자가 맥락에 따라 읽기쓰기 해석됨 |


---

## 4. 실행적 이중성 요약 (Cases 5–8)

| Case | 구성 요소                      | 이중성 설명                                        |
|------|-------------------------------|---------------------------------------------------|
| 5    | WorkBit = R ⊕ G ⊕ F ⊕ H       | FSM 기반 상태 흐름 표현                              |
| 6    | φ(θ) = 위상 표현 ⊕ 상태 유추     | 센서 조합 기반의 실행 위치 수치화                       |
| 7    | Tag = Semantic ⊕ Binding     | 의미 이름과 물리적 주소의 이중 연결 구조                 |
| 8    | Arrow = Start ⊕ Reset        | 인과 신호의 역할 분리 (연속 신호와 초기화 트리거)           |

---

## 5. 이중성 설계가 주는 효과

### ▸ 설계 측면
- 명확한 구성 요소 정의와 재사용성 향상
- 설계-실행 간의 추상화 경계 확립

### ▸ 실행 측면
- 흐름 해석의 명시성과 자동화 가능성 향상
- 상태 기반의 제어 로직 설계 용이

### ▸ 시스템 통합 측면
- 계층 간 결합도 감소 및 상호 운용성 강화
- 분산 실행과 참조 기반 설계의 공존 가능

---

## 6. 이중성 설계 원칙 요약

- **Bit는 고정된 구조체가 아니라 흐름의 관찰점**
- **모든 구성은 흐름(Arrow) 안에서 원인 ⊕ 결과로 해석됨**
- **ApiDef의 지시 및 관찰 인터페이스 존재 여부가 해석 기준**
- **반복 구조 안에서 구조적, 실행적 이중성이 함께 순환됨**

---

개별 사례(Case 1~8)의 상세한 설명은 별도의 문서에서 확인할 수 있습니다.



## 🌐 DS Duality 이중성: Case 1 — System ⊕ Device

### 1. 개념 소개

DS 시스템은 특정 상황에 따라 "System" 또는 "Device" 역할을 수행할 수 있으며, 이 두 가지는 배타적이지 않고 동적으로 전환됩니다. 이를 **System ⊕ Device 이중성**이라 합니다.

* **System**: 외부 시스템에 명령을 보내는 능동적 실행 주체
* **Device**: 외부에서 호출받아 응답하는 수동적 실행 대상

> ⊕ (XOR): 동일 시점에는 하나의 역할만 수행하되, 전환은 가능함

### 2. 두 가지 역할 정의

#### 2.1 System (Active System)

* **정의**: 다른 시스템을 호출하고 실행 흐름을 주도하는 주체
* **대표 행위**: `ApiCall`을 사용하여 외부의 `ApiDef` 호출
* **특징**:

  * 외부 제어 흐름을 개시함
  * 요청/응답에 대한 책임을 가짐

#### 2.2 Device (Passive System)

* **정의**: 외부로부터 호출되어 동작하는 대상 시스템
* **대표 행위**: `ApiDef`를 통해 외부 요청에 반응함
* **특징**:

  * 내부 FSM 흐름을 포함할 수 있음
  * 외부에서는 내부 로직을 직접 제어할 수 없음

### 3. 이중성 원리

#### 3.1 동적 역할 전환

```text
[상황 1]
A.ApiCall → B.ApiDef
→ A = System (능동 호출)
→ B = Device (응답 수신)

[상황 2]
B.ApiCall → A.ApiDef
→ B = System (능동 호출)
→ A = Device (응답 수신)
```

#### 3.2 수평적 구조

* 시스템 간 호출 관계는 부모-자식이 아닌 형제 구조
* 호출 방향에 따라 역할이 유동적으로 변함

### 4. 실생활 예시

#### 제조 자동화 시스템

* **컨베이어 (A)** → 로봇팔 (B): 제품 전달 요청 → A는 System, B는 Device
* **로봇팔 (B)** → 컨베이어 (A): 픽업 완료 알림 → B는 System, A는 Device

### 5. 구현 구조

#### 5.1 호출 흐름

```text
System A
  └─ ApiCall ──▶ System B
                    └─ ApiDef
```

#### 5.2 흐름 요약

* ApiCall 보내는 쪽 → System (능동)
* ApiDef 응답하는 쪽 → Device (수동)
* 하나의 시스템이 두 역할을 모두 가질 수 있음 (단, 동시에 수행하지는 않음)

### 6. 주의사항

#### 6.1 순환 호출 가능성

```text
A.ApiCall → B.ApiDef
B.ApiCall → A.ApiDef
```

* 정상적으로 작동할 수 있으나, Deadlock 가능성 주의 필요
* 순환 경로 발생 시 경고 메시지 제공이 바람직

#### 6.2 상태 가시성

* 외부에서 Device의 상태는 `ApiDef` 응답 로그로만 유추 가능
* 내부 FSM 흐름은 직접 관찰 불가

#### 6.3 내부 Controller 존재

* Device도 내부적으로는 항상 Controller(FSM 등)를 갖고 있음
* 단지 외부에서 접근할 수 없는 것뿐


### 7. 설계 고려사항

* **명확한 흐름 설계**: 각 System이 언제 어떤 역할을 수행할지를 명시
* **Deadlock 예방**: 무한 루프 가능성 있는 경로 사전 탐지
* **디버깅 전략**: 각 ApiCall/ApiDef의 상태 로그 분석 및 시각화 필요

### 8. 정리

DS의 **System ⊕ Device 이중성**은 시스템 간 동적 호출 구조를 수평적이고 유연하게 구성할 수 있게 해줍니다.

* 하나의 시스템이 상황에 따라 두 역할을 오가며 작동
* 호출 흐름은 명확히 설계되되, 실행 중 동적으로 전환 가능
* 외부-내부 구조 분리로 재사용성과 안정성을 확보
## 🌐 DS Duality 이중성: Case 2 — Instance ⊕ Reference

### 1. 개념 소개

DS 시스템은 실제 물리 시스템과 1:1로 연결되는 디지털 트윈 구조를 갖습니다. 이 설계 원칙에 따라 DS는 동일한 시스템 정의라도 **생성 방식**에 따라 두 가지 형태로 구분합니다:

* **Instance**: 새로운 프로젝트에서 `new`로 직접 생성된 시스템. 물리 시스템과 연동되지 않은 상태에서 정의되며, 내부 구성과 실행 로직을 포함하고 있어 Active 모드일 경우 직접 실행이 가능합니다.
* **Reference**: 기존에 정의된 Instance를 참조하는 시스템. 기존 물리 시스템과 연동하기 위해 사용되며, 항상 Passive로 동작하며 직접 실행은 불가능합니다.

> 하나의 시스템 정의는 최초 생성 시 Instance로 시작하고, 이후 다른 프로젝트에서는 해당 시스템을 Reference로 참조함으로써 **재사용**과 **물리적 연결 보존**을 동시에 실현합니다.

### 2. 이중성 구조 해석

| 항목       | Instance                  | Reference                |
| -------- | ------------------------- | ------------------------ |
| 정의 방식    | new로 생성된 시스템              | 기존 시스템을 참조               |
| 실행 가능성   | ✅ Active 설정 시 실행 가능       | ❌ 항상 Passive (읽기 전용)     |

### 3. 트윈 시스템 연동 관점

DS 시스템은 현실 물리 시스템과 가상 그래프 시스템을 각각 쌍(Pair)으로 구성합니다. 이로 인해:

* **Reference 구조**는 이미 존재하는 물리 시스템과 DS 트윈을 연결할 때 필요합니다.
* 시스템을 직접 생성하여 새로운 설비를 정의하는 경우에는 **Instance 구조**를 사용합니다.

### 4. 설계 및 운영 가이드

* 새로운 프로젝트에서는 반드시 시스템을 Instance로 정의해야 함
* 동일한 물리 시스템을 참조하고자 할 경우 Reference 구조 사용
* 시스템 정의 변경은 Instance를 통해서만 가능하며, Reference는 읽기 전용
* 순환 참조 및 동일 시스템의 중복 연결은 사전에 방지해야 함

### 5. 정리

**Instance ⊕ Reference 이중성**은 DS 시스템의 물리-가상 일체형 설계에서 중요한 원리입니다.

* 시스템은 최초 정의 시 Instance, 이후 재사용 시 Reference로 분기됨
* Instance는 정의와 실행이 가능하며, Reference는 실행은 불가능하지만 실제 물리 시스템과의 연동에 핵심 역할을 수행
* 이중성 구조는 DS의 확장성과 트윈 시스템 구성에 유연성을 제공합니다.



## 🌐 DS Duality 이중성: Case 3 — Arrow 인과 연결과 Bit 이중성

### 1. 개념 소개

DS 시스템에서 실행 흐름을 구성하는 최소 단위는 **Bit**입니다. 이 Bit는 단순한 신호 상태가 아닌, **Arrow를 통한 인과적 연결** 속에서 의미를 가집니다. Bit는 시스템 내에서 특정 결과를 유도하는 동시에, 다음 동작의 원인이 되는 구조로 작동하며, 따라서 Bit는 **원인이자 결과**라는 이중적 특성을 지닙니다.

Bit 자체는 관찰자나 구조 설계자에 의해 Work 또는 Call처럼 분류될 수 있으나, 이는 Bit 고유의 속성이 아닌, 해석의 관점에 따른 것입니다. 즉, Bit는 역할을 수행하는 구조적 객체가 아니라, 흐름에 따라 원인 또는 결과로 해석되는 **관계 중심의 노드**입니다.

> Bit는 이중성을 가지지만, Work/Call은 구조적으로 정의된 단위로서 이중성이 아닌 고정 타입입니다.

---

### 2. 인과 연결: Arrow를 통한 원인-결과 구조

```text
    A (Bit)
     │
     ▼
    B (Bit)
     │
     ▼
    C (Bit)
```

* **B는 A의 결과이자 C의 원인**입니다.
* Bit는 항상 이전 흐름에 의해 유도되고, 다음 흐름을 유도하는 **중간 인과 노드**입니다.
* 따라서 Bit는 실행 흐름 내에서 **결과이자 원인**인 이중 해석의 지점을 형성합니다.

---

### 3. 관점에 따른 Bit 해석

```text
[외부 관찰자 관점]
ApiDef
   │
   ▼
 Bit A  → 외부에 의해 트리거된 경우 "Work"로 보이며 결과로 해석됨

[내부 흐름 관점]
Bit A ──▶ Bit C  → Bit A는 Bit C의 원인으로 해석됨
```

Bit는 외부 ApiDef에 의해 호출될 경우 결과로 해석되며, 이어지는 Bit가 존재한다면 그에 대한 **원인**으로도 해석됩니다. 이처럼 Bit는 **결과로 해석되면서 동시에 다음 동작을 유발하는 원인으로 작용**할 수 있습니다.

---

### 4. ApiDef → Work(Bit) → Call(Bit) → ApiCall(Tag) → ApiDef 반복 구조

* DS 시스템에서는 Bit가 **Work처럼 작동하는 단계**와 **Call처럼 작동하는 단계**를 거치며 반복적인 연결 구조를 형성할 수 있습니다.

```text
ApiDef → Work(Bit Group) → Call(Bit Group) → ApiCall(Tag) → ApiDef → (반복)
```

* **Work(Bit)**: 시스템 루트에서 선언되는 Bit 그룹으로, 외부 ApiDef에 의해 트리거되고, 관찰 대상이 됨
* **Call(Bit)**: Work 내부에 존재하는 Bit 그룹으로, 외부 시스템을 호출하는 ApiCall을 포함함
* **ApiCall → ApiDef** 연결은 다음 시스템에서 다시 Bit 그룹(Work)으로 변환되어 순환적 구조 형성

이 구조는 **Bit의 흐름을 중심으로 해석되는 동적 연결 구조**로서, 반복되는 시스템 호출과 응답을 유연하게 구성할 수 있습니다.

---

### 5. 정리

* **Bit는 DS 시스템의 실행 흐름에서 원인이자 결과로 작동하는 이중적 존재**입니다.
* **Arrow는 흐름의 인과를 형성하며, Bit의 의미를 규정짓는 해석 도구**입니다.
* **ApiDef 구조가 존재할 경우, Bit들의 지시/관찰 경계가 형성되어 해당 Bit들이 Work처럼 해석될 수 있으며, 내부 Bit 그룹은 다시 Call처럼 연결될 수 있습니다.**
* 결과적으로 DS 시스템은 Bit 기반 흐름에서 시작하여, **ApiDef → Work → Call → ApiCall → ApiDef** 구조를 반복하는 계층적 인과 연결 체계를 형성합니다.

## 🌐 DS Duality 이중성: Case 4 — ApiCall → Tag → ApiDef

### 1. 개념 소개

DS 시스템에서 ApiCall과 ApiDef은 시스템 간 연결을 위한 기본 구조를 구성합니다. 이 연결은 단순한 함수 호출이 아니라, **Tag**라는 매개체를 통해 데이터를 전달하고 수신하는 구조로 설계됩니다.

Tag는 단순한 변수나 공유 메모리가 아니라, **물리적으로 서로 다른 두 시스템 간에 데이터를 전달하는 쌍(pair) 구조의 인터페이스**입니다. ApiCall은 **Active System** 입장에서 쓰기(Write) 동작을 수행하며, ApiDef는 **Passive System** 입장에서 읽기(Read) 동작만 수행합니다.

이때 Passive System은 Tag에 데이터를 기록하는 내부 처리 로직을 수행하지만, DS 모델 상에서는 **ApiDef는 Tag를 읽을 뿐이며, 해당 동작에는 관여하지 않습니다.** 즉, Passive 쪽은 내부에서 Tag를 통해 물리적으로 처리되고 있다고 가정됩니다.

> 이때, DS의 관찰 범위는 Tag에 대한 접근만 포함되며, Passive 시스템 내부의 물리 처리 로직은 관찰 대상이 아닙니다.

---

### 2. Tag의 Pair 구조와 역할

```text
[Active System - ApiCall] ──▶ Tag ──▶ [Passive System - ApiDef]
         (Write)                             (Read)
```

| 요소          | 역할 관점      | 동작 유형      | 시스템 유형  | 설명                        |
| ----------- | ---------- | ---------- | ------- | ------------------------- |
| **ApiCall** | 쓰기 (Write) | Tag에 값 설정  | Active  | 외부 시스템에 명령을 전달하기 위해 값을 설정 |
| **ApiDef**  | 읽기 (Read)  | Tag에서 값 읽기 | Passive | 전달된 값을 수신하여 내부 작업 수행      |
| **Tag**     | 데이터 경계점    | 쌍(Pair) 구조 | 공유 아님   | 두 시스템 간 데이터를 매개하는 경계 지점   |

* Tag는 공유 메모리 개념이 아닌, **양방향 공유되지 않는 일방향 전달 쌍(pair) 구조**로 설계됨
* ApiDef는 값을 "읽기만" 하며, 값 설정에는 관여하지 않음
* Tag는 DS 모델에서 유일하게 관찰 가능한 정보로, 시스템 간 연결의 중심

---

### 3. 관찰 불가능한 내부 처리와 Timeout 감지

Passive System은 외부로부터 ApiCall에 의해 값을 전달받지만, 실제 처리는 해당 시스템 내부에서 물리적으로 수행됩니다. DS에서는 이러한 내부 처리를 직접 관찰할 수 없기 때문에, 다음과 같은 방식으로 **이상 감지 또는 타임아웃 판단**을 수행합니다:

* **시간 기반 지시-관찰 타이밍 감지**

  * ApiCall을 통해 Tag에 값이 설정되면, 일정 시간 내에 ApiDef 측의 수신 응답이 예상됨
  * 이 시간이 초과될 경우 **타임아웃 경고** 또는 **실패 처리**를 수행함

---

### 4. 반복되는 구조

```text
ApiCall → Tag → ApiDef → Work → Call → ApiCall → Tag → ApiDef → ...
```

* Tag를 기준으로 시스템 간 연결이 반복되는 구조
* 각각의 Tag는 새로운 두 시스템의 연결을 형성하며, 이 구조는 **무한히 중첩 가능한 구조**
* DS는 이 구조를 통해 **계층적이면서도 유연한 흐름 구성**을 가능하게 함

---

### 5. 결론

* Tag는 **읽기/쓰기 관점의 쌍(pair) 구조로 정의되며**, 공유 구조가 아님
* **Passive 측은 내부적으로 물리적으로 Tag를 처리하지만, DS 모델은 관찰 불가**
* DS는 **ApiCall → Tag → ApiDef** 구조를 관찰 가능한 단위로 하여 모델링함
* **이상 감지 또는 예외 처리는 시간 기반 관찰 방식(지시 후 응답 감시)을 통해 구현**
* 이 구조는 **DS 전체 흐름의 연결성을 구성하는 기본 단위이자, 반복 가능한 설계 패턴**






## DS Duality 이중성: Case 5 — WorkBit = Ready ⊕ Going ⊕ Finish ⊕ Homing

### 1. 개념 소개

DS 시스템에서 Work는 네 가지 상태(R, G, F, H)를 가지며, 이 상태는 단일 비트(WorkBit)와 외부 신호 조건에 따라 전이됩니다. WorkBit은 단순 플래그가 아니라, 실행 흐름 전체를 표현하는 핵심 FSM(Finite State Machine) 구조를 담고 있습니다.

* **Ready (R)**: 실행 준비 상태
* **Going (G)**: 작업 실행 중
* **Finish (F)**: 실행 완료됨
* **Homing (H)**: 초기화 진행 중

> ⊕: WorkBit는 하나의 비트로 네 가지 상태 전이를 표현하며, 외부 신호에 따라 의미가 동적으로 바뀜

### 2. 상태 전이 조건

```text
Ready ── Start 신호 ──▶ Going
Going ── 내부 작업 완료 ──▶ Finish
Finish ── Reset 신호 ──▶ Homing
Homing ── 초기화 완료 ──▶ Ready
```

#### 2.1 Ready → Going 전이

* **트리거 조건**: 외부 Start 신호 수신
* **동작 방식**: 이전 Work의 작업 완료 신호를 받아 실행 시작
* **특징**: 
  - 실행 준비가 완료된 상태에서만 Going으로 전이 가능
  - Start 신호는 외부 Arrow 조건에 의해 결정됨

#### 2.2 Going → Finish 전이

* **트리거 조건**: Work 내부 작업(Call 시퀀스) 완료
* **동작 방식**: 모든 내부 Call이 성공적으로 완료되면 자동 전이
* **특징**:
  - 내부 작업 진행 상황과 무관하게 완료 시점에서 즉시 전이
  - 외부 개입 없이 자율적으로 결정됨

#### 2.3 Finish → Homing 전이

* **트리거 조건**: 외부 Reset 신호 수신
* **동작 방식**: 작업 완료 후 초기화 명령을 받아 복귀 프로세스 시작
* **특징**:
  - Reset 신호는 외부 Arrow 조건에 의해 결정됨
  - 자동 복귀가 아닌 명시적 신호 기반 전이

#### 2.4 Homing → Ready 전이

* **트리거 조건**: 초기화 프로세스 완료
* **동작 방식**: 시스템 상태를 초기 조건으로 복원 후 자동 전이
* **특징**:
  - 내부 초기화 작업 완료 후 자율적 전이
  - 다음 작업 수행을 위한 준비 완료 상태로 복귀

### 3. 상태 전이 다이어그램

```text
    ┌─────────────────────────────────────┐
    │                                     │
    ▼                                     │
 Ready ──Start 신호──▶ Going ──완료──▶ Finish
    ▲                                     │
    │                                     │
    │                                     │Reset 신호
    │                                     │
    │                                     ▼
 Homing ◀────────── 초기화 완료 ──────── (Reset 실행)
```

### 4. 예시 흐름 시나리오

```text
시간:           0    1    2    3    4    5    6    7
Work 상태:      R    G    G    F    F    H    R    R
Start 신호:     0    1    0    0    0    0    0    0
Reset 신호:     0    0    0    0    1    0    0    0
내부 작업:      -    진행  완료  -    -    초기화 완료 -
```

**상세 설명:**
- **t=1**: Start 신호로 Ready → Going 전이
- **t=2**: Going 상태에서 내부 작업 진행
- **t=3**: 내부 작업 완료로 Going → Finish 전이
- **t=4**: Reset 신호로 Finish → Homing 전이  
- **t=5**: 초기화 진행 중
- **t=6**: 초기화 완료로 Homing → Ready 전이

### 5. 이중성 설명

* **단일 비트로 다중 상태 표현**: WorkBit 하나로 R/G/F/H 네 가지 상태 관리
* **내부 자율성과 외부 제어**: Going↔Finish는 내부 로직, Ready↔Going 및 Finish↔Homing은 외부 신호
* **순환 구조**: 네 상태가 순환하며 지속적인 작업 수행 가능

### 6. 설계 시 유의사항

#### 6.1 상태 전이 안정성
* Start와 Reset 신호가 동시에 활성화되지 않도록 신호 설계
* 각 상태 전이는 원자적(atomic)으로 처리되어 중간 상태 방지

#### 6.2 내부 작업 완료 조건
* Going 상태에서 Finish로의 전이 조건을 명확히 정의
* 내부 Call 시퀀스의 오류 처리 메커니즘 구축

### 7. 실제 적용 예시

#### 7.1 컨베이어 시스템
```text
Ready (대기) → Going (이송) → Finish (도착) → Homing (복귀) → Ready
```

#### 7.2 로봇 팔 동작
```text
Ready (대기) → Going (작업) → Finish (완료) → Homing (홈복귀) → Ready
```

### 8. 상태 관리 매트릭스

| 상태 | 진입 조건 | 종료 조건 | 제어 주체 | 특징 |
|------|----------|----------|----------|------|
| Ready | Homing 완료 | Start 신호 | 외부 | 실행 대기 상태 |
| Going | Start 신호 | 내부 작업 완료 | 내부 | 실행 중 |
| Finish | Going 완료 | Reset 신호 | 외부 | 완료 상태 |
| Homing | Reset 신호 | 초기화 완료 | 내부 | 복귀 프로세스 |

---






## DS Duality 이중성: Case 6 — φ(θ) = 위상 표현 ⊕ 상태 유추

### 1. 개념 소개

DS에서는 각 Work가 주어진 시점에서 고유한 상태를 갖습니다. 이 상태를 수치적으로 표현하기 위해, Work의 센서 입력 및 상태 조건을 기반으로 **위상(Phase) 값 φ(θ)** 를 계산합니다. 이는 시간 기반이 아닌 **상태 기반 위상 표현**으로, 각 Work의 현재 위치 또는 진행 상황을 수학적으로 정의하는 방식입니다.

* **θ (Theta)**: Work 내부 조건이나 센서 상태가 주어지는 시점 (불연속 상태 인덱스)
* **φ(θ)**: 해당 시점의 위상 값

> 위상은 상태 추정과 비교 판단을 위한 수치 지표로 사용됨

### 2. 위상 계산 공식

#### 2.1 Binary 기반 계산 (2진법)

$\phi_\theta = \frac{1}{2^n} \sum_{i=1}^{n} \left(2^{i-1} \cdot V_i \cdot C_{i,\theta}\right) \cdot 2\pi$

#### 2.2 Exponential 기반 계산 (지수 가중치)

$\phi_\theta = \frac{1}{e^n} \sum_{i=1}^{n} \left(e^{i-1} \cdot V_i \cdot C_{i,\theta}\right) \cdot 2\pi$

#### 2.3 Log 기반 정규화

$\phi_\theta = \ln \left(\sum_{i=1}^{n} e^{i-1} \cdot V_i \cdot C_{i,\theta}\right) \cdot \frac{2\pi}{n}$

* $V_i$: i번째 센서 값 또는 상태 비트
* $C_{i,\theta}$: 해당 시점 θ에서 조건 충족 여부 (0 or 1)

### 3. 활용 예시

#### 3.1 센서 입력에 따른 위상 결정

```text
Sensor A: ON (1)
Sensor B: OFF (0)
Sensor C: ON (1)
→ 위상 φ(θ) = 특정 각도로 계산됨
```

#### 3.2 동일한 φ(θ) 값 비교

* 서로 다른 시스템이 동일한 φ(θ)를 가질 경우 상태 동기화 판단 가능
* 일정 범위 내 유사한 φ(θ)는 유사 상태로 간주 가능

### 4. 이중성 설명

* **수치 표현 (Continuous)**: 상태를 단일 숫자 (위상)로 표현 가능
* **이산 상태 (Discrete)**: 실제 입력은 이진 조건 (0/1) 기반 → 상태 조합으로 위상 유도

### 5. 설계 시 고려사항

* 위상은 상태를 직접 조회할 수 없는 상황에서 추정 지표로 활용됨
* 센서 노이즈나 임계값 문제로 인한 위상 급변 주의
* 일정 φ(θ) 간 차이가 명확한 의미를 가질 수 있도록 조건 설계 필요

### 6. 실제 적용 시나리오

#### 6.1 디지털 트윈 상태 정렬

* 실제 설비와 시뮬레이션 시스템의 위상을 비교하여 동기화 상태 판단

#### 6.2 알람/오류 탐지

* φ(θ)의 급변 또는 역진행이 발생할 경우 이상 징후로 판단 가능

### 7. 정리

φ(θ) = 상태 기반 위상 표현 ⊕ 센서 조합 함수

* Work의 현재 상태를 수치적으로 비교 가능하게 하여 상태 추정 및 진단에 사용
* 센서나 내부 조건에 기반한 위상 함수 정의를 통해, Work 상태의 고유 지표로 활용됨
* 단순 상태값(R/G/F/H)을 넘어서, 비교와 예측 가능한 **상태 지표화 메커니즘** 제공











## DS Duality 이중성: Case 7 — Tag = SemanticLink ⊕ PhysicalBinding

### 1. 개념 소개

Tag는 DS 시스템에서 ApiCall과 ApiDef 간 데이터 교환을 가능하게 하는 매개체이며, 의미론적 연결과 물리적 바인딩의 이중적인 역할을 수행합니다. 이 Tag는 단순한 변수명이 아닌, 시스템 전체를 연결하는 핵심 연결점입니다.

* **SemanticLink (의미 연결)**: 기능적 의미에 따라 명명된 추상적 변수 (예: "StartSensor")
* **PhysicalBinding (물리적 매핑)**: 실제 디지털/아날로그 주소 또는 메모리 위치와 연결됨

> ⊕: 하나의 Tag는 의미와 물리 매핑을 동시에 가짐

### 2. 구성 요소 정의

#### 2.1 SemanticLink

* **정의**: 동작의 의미를 설명하는 이름
* **예시**: StartCommand, RobotArmReady, TempHighFlag
* **용도**:

  * 설계자와 사용자 간 의미 전달
  * 로직 문서화와 명세화

#### 2.2 PhysicalBinding

* **정의**: 실제 하드웨어 주소 혹은 내부 변수에 연결
* **예시**: X100, Y102, M300, DB100.DBX0.2
* **용도**:

  * I/O 연동, PLC 메모리 맵핑
  * 시뮬레이터 또는 물리 디바이스와 연결

### 3. 데이터 타입 분류

* **Digital (Bool)**: ON/OFF, True/False
* **Analog (Float, Int)**: 센서 수치, 온도 값 등
* **Enum (열거형)**: 상태 코드, 모드 구분 등

### 4. 구조 예시

```json
{
  "tagName": "StartSignal",
  "semantic": "Start",
  "binding": "X100",
  "type": "Digital"
}
```

* 이 Tag는 의미상 "Start" 명령이며, 실제로는 X100 입력을 바인딩함

### 5. 이중성 설명

* **설계 vs 실행**: 설계자 입장에서 Tag는 의미로 정의되지만, 런타임에서는 실제 바인딩 주소로 동작
* **추상 vs 구체**: 의미적 표현과 물리적 표현을 하나로 통합하여 시스템 해석과 구현을 동시에 만족시킴

### 6. 활용 예시

#### 6.1 ApiCall → ApiDef 간 데이터 전달

```text
ApiCall (출력) → Tag → ApiDef (입력)
```

* Tag는 호출자와 피호출자 간 인터페이스 역할

#### 6.2 시뮬레이션 및 디버깅

* 물리 바인딩이 없는 상태에서 의미 기반 테스트 가능
* 물리 주소가 없는 Virtual I/O 구성도 지원

### 7. 설계 시 고려사항

* 의미 이름 충돌 방지: 동일한 의미 이름은 프로젝트 내에서 고유해야 함
* 바인딩 주소 유효성 검증: 존재하지 않는 I/O 주소 연결 방지
* 복수 바인딩 방지: 하나의 Tag는 하나의 물리 위치에만 바인딩돼야 함

### 8. 정리

Tag = SemanticLink ⊕ PhysicalBinding 이중성은 DS 시스템 내 **모듈 간 데이터 연결, 하드웨어 연동, 시뮬레이션 환경 구성**에 핵심 역할을 하며, 추상화된 의미와 실제 시스템을 연결하는 중요한 다리 역할을 합니다.





## DS Duality 이중성: Case 8 — Arrow = Start ⊕ Reset

### 1. 개념 소개

Arrow는 DS 시스템 내에서 Work 간의 실행 흐름을 제어하는 신호선이며, **Start**와 **Reset** 두 가지 논리적 의미를 동시에 내포합니다. Arrow는 단순 연결선이 아니라 **조건부 신호 생성기**로서 작동하며, 상태 감지와 신호 전달을 통합한 동적 제어 구조입니다.

* **Start**: Finish 상태의 라이징 신호를 감지하여 Start 신호 출력
* **Reset**: Going 상태를 레벨 감지하여 Reset 신호 출력

> ⊕: 하나의 Arrow는 두 가지 감지 조건을 동시에 가지며, 각각 다른 신호를 생성함

### 2. Start와 Reset 신호 생성 조건

#### 2.1 Start 신호 (Finish 라이징 감지)

* **감지 조건**: 이전 Work가 Finish 상태로 전환되는 순간 (Rising Edge)
* **신호 생성**: Finish 상태 진입 시점에서 Start 신호 출력
* **대상**: 다음 Work의 Ready → Going 전이 트리거
* **특징**: 
  - 라이징 엣지 감지로 중복 트리거 방지
  - 일회성 신호로 정확한 타이밍 제어

#### 2.2 Reset 신호 (Going 하이레벨 감지)

* **감지 조건**: Work가 Going 상태를 유지하는 동안 (High Level)
* **신호 생성**: Going 상태가 지속되는 동안 Reset 신호 활성 상태 유지
* **대상**: 해당 Work의 Finish → Homing 전이 조건으로 사용
* **특징**:
  - 레벨 감지로 지속적인 신호 제공
  - Going 상태 종료 시 Reset 신호도 비활성화

### 3. 신호 타이밍 다이어그램

```text
Work A 상태:    R    G    G    F    F    F    F
Work B 상태:    R    R    R    G    G    F    H
Start 신호:     0    0    0    1    0    0    0  (A의 Finish↑)
Reset 신호:     0    0    0    1    1    0    0  (B의 Going 레벨)
```

### 4. Arrow 동작 메커니즘

#### 4.1 Finish 라이징 → Start 신호

```text
Work A: Ready → Going → Finish ↑ (Arrow가 감지)
                           ↓
Arrow: Start 신호 생성 ──▶ Work B: Ready → Going
```

#### 4.2 Going 레벨 → Reset 신호

```text
Work B: Ready → Going ■■■ (Arrow가 레벨 감지)
                  ↓
Arrow: Reset 신호 활성 ──▶ Work B: Finish → Homing 조건 제공
```

### 5. 이중성 설명

* **Start**: 이전 작업의 완료를 감지하여 연쇄 실행 트리거
* **Reset**: 현재 작업의 실행 상태를 감지하여 초기화 조건 제공
* **하나의 Arrow**에서 **두 가지 독립적인 신호 생성 로직**이 동시 작동

### 6. 신호 생성 조건 비교

| 신호 유형 | 감지 방식 | 감지 대상 | 신호 지속성 | 용도 |
|----------|----------|----------|-------------|------|
| Start | 라이징 엣지 | 이전 Work의 Finish | 순간 | 다음 Work 실행 트리거 |
| Reset | 하이 레벨 | 현재 Work의 Going | 지속적 | 현재 Work 초기화 조건 |

### 7. 주의사항 및 설계 가이드

#### 7.1 Finish 라이징 감지의 정확성

* Finish 상태가 지속되는 동안이 아닌, 전환 순간만 감지
* 다중 Work가 동일한 Finish 신호를 받지 않도록 Arrow 설계

#### 7.2 Going 레벨 감지의 안정성

* Going 상태 진입과 동시에 Reset 신호 활성화
* Going 상태 종료 시 Reset 신호도 즉시 비활성화

#### 7.3 순환 참조 방지

* Work A → Work B → Work A 형태의 순환에서 무한 루프 주의
* 종료 조건 또는 횟수 제한 로직 필요

### 8. 실제 적용 예시

#### 8.1 순차 작업 제어

```text
컨베이어 완료(Finish↑) → 로봇팔 시작(Start 신호)
로봇팔 실행(Going■) → 초기화 조건 활성(Reset 신호)
```

#### 8.2 병렬 작업 제어

```text
검사 완료(Finish↑) → 포장A, 포장B 동시 시작(Start 신호)
포장A 실행(Going■) → 포장A 초기화 조건(Reset 신호)
포장B 실행(Going■) → 포장B 초기화 조건(Reset 신호)
```

### 9. 신호 매트릭스

| Arrow 기능 | 입력 조건 | 출력 신호 | 대상 Work | 효과 |
|------------|----------|----------|----------|------|
| Start 생성 | 이전 Work Finish↑ | Start 신호 | 다음 Work | 실행 시작 |
| Reset 생성 | 현재 Work Going■ | Reset 신호 | 현재 Work | 초기화 조건 |

### 10. 정리

Arrow = Start ⊕ Reset 이중성은 DS의 실행 흐름 제어를 더욱 정교하고 예측 가능하게 구성하는 핵심 기제입니다.

**주요 특징:**
* **Start**: Finish 라이징 기반 연쇄 실행 트리거
* **Reset**: Going 레벨 기반 초기화 조건 제공
* **독립적 신호 생성**: 하나의 Arrow에서 두 종류의 신호를 독립적으로 생성
* **정확한 타이밍 제어**: 라이징 엣지와 레벨 감지의 조합으로 안정적 제어

이 구조를 통해 복잡한 산업 자동화 시스템에서도 예측 가능하고 안정적인 실행 흐름을 보장할 수 있습니다.
