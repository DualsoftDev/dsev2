# DS Duality 이중성 개요

## 1. 개요

DS(Dualsoft) 시스템은 복잡한 산업 자동화 환경에서 유연하고 확장 가능한 시스템 설계를 위해 **이중성(Duality)** 개념을 핵심 설계 원리로 채택합니다. 이중성이란 **하나의 구성 요소가 맥락에 따라 역할과 의미가 달라지는 설계 구조**로, 모듈화 및 재사용성, 시스템 간 연결성, 동적 해석 가능성을 극대화합니다.

이중성은 크게 두 가지 범주로 나뉩니다:

- **구조적 이중성 (Structural Duality)**: 시스템 구성 요소 간의 설계 및 역할 분리와 관계
- **실행적 이중성 (Execution Duality)**: 실행 시점에서의 상태 변화, 신호 감지, 인과 흐름의 해석

---

## 2. 이중성의 핵심 원리

1. **동적 역할 전환**: 동일한 객체라도 호출 방향, 관찰 관점, 흐름 조건에 따라 다른 역할 수행
2. **관계 기반 해석**: 객체 자체보다 인과 연결(Arrow)과 주변 관계에 따라 해석
3. **계층적 추상화**: Bit → Call → Work → System → Project 구조로 확장
4. **반복 가능한 흐름 구조**: `ApiDef → Work → Call → ApiCall → ApiDef → ...` 구조가 순환됨

---

## 3. 구조적 이중성 요약 (Cases 1–4)

| Case | 구성 요소                | 이중성 설명                                  |
|------|-------------------------|----------------------------------------------|
| 1    | System ⊕ Device         | 호출 방향에 따라 능동적/수동적 역할 수행           |
| 2    | 원인(Bit) ⊕ 결과(Bit)     | Bit는 흐름 속에서 원인이자 결과로 해석됨             |
| 3    | ApiCall ⊕ ApiDef        | 호출자와 응답자가 맥락에 따라 전환 가능               |
| 4    | Instance ⊕ Reference    | 실행 실체와 참조 대상을 구분하며 설계-사용 분리        |

---

## 4. 실행적 이중성 요약 (Cases 5–8)

| Case | 구성 요소                      | 이중성 설명                                        |
|------|-------------------------------|---------------------------------------------------|
| 5    | WorkBit = R ⊕ G ⊕ F ⊕ H       | FSM 기반 상태 흐름 표현                              |
| 6    | φ(θ) = 위상 표현 ⊕ 상태 유추     | 센서 조합 기반의 실행 위치 수치화                       |
| 7    | Tag = Semantic ⊕ Binding     | 의미 이름과 물리적 주소의 이중 연결 구조                 |
| 8    | Arrow = Start ⊕ Reset        | 인과 신호의 역할 분리 (연속 신호와 초기화 트리거)           |

---

## 5. 이중성 설계가 주는 효과

### ▸ 설계 측면
- 명확한 구성 요소 정의와 재사용성 향상
- 설계-실행 간의 추상화 경계 확립

### ▸ 실행 측면
- 흐름 해석의 명시성과 자동화 가능성 향상
- 상태 기반의 제어 로직 설계 용이

### ▸ 시스템 통합 측면
- 계층 간 결합도 감소 및 상호 운용성 강화
- 분산 실행과 참조 기반 설계의 공존 가능

---

## 6. 이중성 설계 원칙 요약

- **Bit는 고정된 구조체가 아니라 흐름의 관찰점**
- **모든 구성은 흐름(Arrow) 안에서 원인 ⊕ 결과로 해석됨**
- **ApiDef의 지시 및 관찰 인터페이스 존재 여부가 해석 기준**
- **반복 구조 안에서 구조적, 실행적 이중성이 함께 순환됨**

---

개별 사례(Case 1~8)의 상세한 설명은 별도의 문서에서 확인할 수 있습니다.



## 🌐 DS Duality 이중성: Case 1 — System ⊕ Device

### 1. 개념 소개

DS 시스템은 특정 상황에 따라 "System" 또는 "Device" 역할을 수행할 수 있으며, 이 두 가지는 배타적이지 않고 동적으로 전환됩니다. 이를 **System ⊕ Device 이중성**이라 합니다.

* **System**: 외부 시스템에 명령을 보내는 능동적 실행 주체
* **Device**: 외부에서 호출받아 응답하는 수동적 실행 대상

> ⊕ (XOR): 동일 시점에는 하나의 역할만 수행하되, 전환은 가능함

### 2. 두 가지 역할 정의

#### 2.1 System (Active System)

* **정의**: 다른 시스템을 호출하고 실행 흐름을 주도하는 주체
* **대표 행위**: `ApiCall`을 사용하여 외부의 `ApiDef` 호출
* **특징**:

  * 외부 제어 흐름을 개시함
  * 요청/응답에 대한 책임을 가짐

#### 2.2 Device (Passive System)

* **정의**: 외부로부터 호출되어 동작하는 대상 시스템
* **대표 행위**: `ApiDef`를 통해 외부 요청에 반응함
* **특징**:

  * 내부 FSM 흐름을 포함할 수 있음
  * 외부에서는 내부 로직을 직접 제어할 수 없음

### 3. 이중성 원리

#### 3.1 동적 역할 전환

```text
[상황 1]
A.ApiCall → B.ApiDef
→ A = System (능동 호출)
→ B = Device (응답 수신)

[상황 2]
B.ApiCall → A.ApiDef
→ B = System (능동 호출)
→ A = Device (응답 수신)
```

#### 3.2 수평적 구조

* 시스템 간 호출 관계는 부모-자식이 아닌 형제 구조
* 호출 방향에 따라 역할이 유동적으로 변함

### 4. 실생활 예시

#### 제조 자동화 시스템

* **컨베이어 (A)** → 로봇팔 (B): 제품 전달 요청 → A는 System, B는 Device
* **로봇팔 (B)** → 컨베이어 (A): 픽업 완료 알림 → B는 System, A는 Device

### 5. 구현 구조

#### 5.1 호출 흐름

```text
System A
  └─ ApiCall ──▶ System B
                    └─ ApiDef
```

#### 5.2 흐름 요약

* ApiCall 보내는 쪽 → System (능동)
* ApiDef 응답하는 쪽 → Device (수동)
* 하나의 시스템이 두 역할을 모두 가질 수 있음 (단, 동시에 수행하지는 않음)

### 6. 주의사항

#### 6.1 순환 호출 가능성

```text
A.ApiCall → B.ApiDef
B.ApiCall → A.ApiDef
```

* 정상적으로 작동할 수 있으나, Deadlock 가능성 주의 필요
* 순환 경로 발생 시 경고 메시지 제공이 바람직

#### 6.2 상태 가시성

* 외부에서 Device의 상태는 `ApiDef` 응답 로그로만 유추 가능
* 내부 FSM 흐름은 직접 관찰 불가

#### 6.3 내부 Controller 존재

* Device도 내부적으로는 항상 Controller(FSM 등)를 갖고 있음
* 단지 외부에서 접근할 수 없는 것뿐


### 7. 설계 고려사항

* **명확한 흐름 설계**: 각 System이 언제 어떤 역할을 수행할지를 명시
* **Deadlock 예방**: 무한 루프 가능성 있는 경로 사전 탐지
* **디버깅 전략**: 각 ApiCall/ApiDef의 상태 로그 분석 및 시각화 필요

### 8. 정리

DS의 **System ⊕ Device 이중성**은 시스템 간 동적 호출 구조를 수평적이고 유연하게 구성할 수 있게 해줍니다.

* 하나의 시스템이 상황에 따라 두 역할을 오가며 작동
* 호출 흐름은 명확히 설계되되, 실행 중 동적으로 전환 가능
* 외부-내부 구조 분리로 재사용성과 안정성을 확보



## 🌐 DS Duality 이중성: Case 2 — Arrow 인과 연결과 Bit 이중성

### 1. 개념 소개

DS 시스템에서 실행 흐름을 구성하는 최소 단위는 **Bit**입니다. 이 Bit는 단순한 신호 상태가 아닌, **Arrow를 통한 인과적 연결** 속에서 의미를 가집니다. Bit는 시스템 내에서 특정 결과를 유도하는 동시에, 다음 동작의 원인이 되는 구조로 작동하며, 따라서 Bit는 **원인이자 결과**라는 이중적 특성을 지닙니다.

Bit 자체는 관찰자나 구조 설계자에 의해 Work 또는 Call처럼 분류될 수 있으나, 이는 Bit 고유의 속성이 아닌, 해석의 관점에 따른 것입니다. 즉, Bit는 역할을 수행하는 구조적 객체가 아니라, 흐름에 따라 원인 또는 결과로 해석되는 **관계 중심의 노드**입니다.

> Bit는 이중성을 가지지만, Work/Call은 구조적으로 정의된 단위로서 이중성이 아닌 고정 타입입니다.

---

### 2. 인과 연결: Arrow를 통한 원인-결과 구조

```text
    A (Bit)
     │
     ▼
    B (Bit)
     │
     ▼
    C (Bit)
```

* **B는 A의 결과이자 C의 원인**입니다.
* Bit는 항상 이전 흐름에 의해 유도되고, 다음 흐름을 유도하는 **중간 인과 노드**입니다.
* 따라서 Bit는 실행 흐름 내에서 **결과이자 원인**인 이중 해석의 지점을 형성합니다.

---

### 3. 관점에 따른 Bit 해석

```text
[외부 관찰자 관점]
ApiDef
   │
   ▼
 Bit A  → 외부에 의해 트리거된 경우 "Work"로 보이며 결과로 해석됨

[내부 흐름 관점]
Bit A ──▶ Bit C  → Bit A는 Bit C의 원인으로 해석됨
```

Bit는 외부 ApiDef에 의해 호출될 경우 결과로 해석되며, 이어지는 Bit가 존재한다면 그에 대한 **원인**으로도 해석됩니다. 이처럼 Bit는 **결과로 해석되면서 동시에 다음 동작을 유발하는 원인으로 작용**할 수 있습니다.

---

### 4. ApiDef → Work(Bit) → Call(Bit) → ApiCall(Tag) → ApiDef 반복 구조

* DS 시스템에서는 Bit가 **Work처럼 작동하는 단계**와 **Call처럼 작동하는 단계**를 거치며 반복적인 연결 구조를 형성할 수 있습니다.

```text
ApiDef → Work(Bit Group) → Call(Bit Group) → ApiCall(Tag) → ApiDef → (반복)
```

* **Work(Bit)**: 시스템 루트에서 선언되는 Bit 그룹으로, 외부 ApiDef에 의해 트리거되고, 관찰 대상이 됨
* **Call(Bit)**: Work 내부에 존재하는 Bit 그룹으로, 외부 시스템을 호출하는 ApiCall을 포함함
* **ApiCall → ApiDef** 연결은 다음 시스템에서 다시 Bit 그룹(Work)으로 변환되어 순환적 구조 형성

이 구조는 **Bit의 흐름을 중심으로 해석되는 동적 연결 구조**로서, 반복되는 시스템 호출과 응답을 유연하게 구성할 수 있습니다.

---

### 5. 정리

* **Bit는 DS 시스템의 실행 흐름에서 원인이자 결과로 작동하는 이중적 존재**입니다.
* **Arrow는 흐름의 인과를 형성하며, Bit의 의미를 규정짓는 해석 도구**입니다.
* **ApiDef 구조가 존재할 경우, Bit들의 지시/관찰 경계가 형성되어 해당 Bit들이 Work처럼 해석될 수 있으며, 내부 Bit 그룹은 다시 Call처럼 연결될 수 있습니다.**
* 결과적으로 DS 시스템은 Bit 기반 흐름에서 시작하여, **ApiDef → Work → Call → ApiCall → ApiDef** 구조를 반복하는 계층적 인과 연결 체계를 형성합니다.


## DS Duality 이중성: Case 3 — ApiCall ⊕ ApiDef

### 1. 개념 소개

DS 구조에서 시스템 간 통신은 ApiCall과 ApiDef의 연결을 통해 이루어집니다. 이 둘은 각각 \*\*요청(Request)\*\*과 \*\*응답(Response)\*\*의 역할을 가지며, 함께 시스템 간 데이터 흐름과 실행 트리거를 구성합니다. 이 구조는 단방향 호출 뿐 아니라, 제어 및 상태 전달의 핵심 축이 됩니다.

* **ApiCall**: 외부 시스템의 기능을 호출하는 요청 단자
* **ApiDef**: 외부에서 호출되는 기능의 정의이자 응답 단자

> ⊕: ApiCall과 ApiDef는 짝을 이루며 하나의 흐름을 구성함

### 2. 구조 정의

#### 2.1 ApiCall

* **정의**: 현재 시스템이 외부 시스템의 ApiDef를 호출하기 위한 진입점
* **동작 방식**: 조건 만족 시 화살표(Arrow)를 통해 호출 시작
* **특징**:

  * 실행 조건 정의 가능 (Start, Delay 등)
  * Tag를 통해 입력값 전달

#### 2.2 ApiDef

* **정의**: 외부에서 호출될 수 있도록 정의된 함수형 인터페이스
* **동작 방식**: 호출을 받으면 내부 Work를 실행
* **특징**:

  * 외부 ApiCall에 의해 트리거됨
  * 실행 결과를 Tx Tag로 응답

### 3. 흐름 예시

```text
System A
  └─ ApiCall ──▶ System B
                    └─ ApiDef ──▶ B.Work
```

* A는 명령을 전송하는 능동적 주체 (System)
* B는 이를 수신하고 실행하는 피동적 주체 (Device)

### 4. 이중성 효과

* **연결성 강화**: 시스템 간 명확한 데이터 경로 제공
* **의존성 표현**: 호출 방향을 통해 흐름 의존 관계 명시
* **모듈 분리**: 외부 요청과 내부 구현 분리 가능

### 5. 역할 전이와 순환 예시

```text
호출 구조:
B.ApiCall → A.ApiDef
A.ApiCall → C.ApiDef
→ 다단계 연결 가능 (Chain 구조)

순환 가능성:
A.ApiCall → B.ApiDef
B.ApiCall → A.ApiDef
→ 설계자의 명시적 의도일 경우 허용
```

### 6. 주의사항

#### 6.1 순환 호출 방지

* 의도치 않은 무한 루프 발생 가능
* 실행 횟수 제한 또는 루프 감지 필요

#### 6.2 실행 조건 검증

* ApiCall은 Arrow의 상태에 따라 트리거되므로 조건 로직 주의
* ApiDef가 실행 가능한 상태인지 체크 필요

#### 6.3 상태 추적 및 오류 처리

* 호출 실패, 지연, 타임아웃 등의 예외 상황 처리 필요
* 로깅 기반 디버깅 체계 구축 권장

### 7. 매트릭스 요약

| 구성 요소   | 역할  | 트리거 방식 | 대상 연결     | 반환값 제공  |
| ------- | --- | ------ | --------- | ------- |
| ApiCall | 요청자 | Arrow  | 외부 ApiDef | Tag로 전달 |
| ApiDef  | 응답자 | 외부 호출  | 내부 Work   | Tag로 응답 |

### 8. 정리

**ApiCall ⊕ ApiDef 이중성**은 DS 시스템에서 **시스템 간 연결성과 모듈 간 경계**를 명확히 하며, 실행 트리거와 데이터 전달을 효율적으로 수행할 수 있도록 지원합니다. 이를 통해 각 시스템은 독립적이면서도 상호 작용 가능한 구조를 갖게 됩니다.


## DS Duality 이중성: Case 4 — Instance ⊕ Reference

### 1. 개념 소개

DS 시스템에서 System은 프로젝트 생성 순서와 사용 방식에 따라 **Instance** 또는 **Reference** 역할을 수행합니다. 동일한 시스템이라도 **최초 생성하는 프로젝트에서는 Instance**가 되고, **후에 활용하는 프로젝트에서는 Reference**가 되는 이중적 특성을 가집니다.

* **Instance**: 시스템을 최초로 생성하고 직접 제어하는 실행 실체
* **Reference**: 기존에 생성된 Instance를 참조하여 간접적으로 활용하는 참조 객체

> ⊕: 동일한 시스템이 프로젝트 관점에 따라 Instance 또는 Reference 역할을 수행

### 2. 구성 요소 정의

#### 2.1 Instance (직접 실행 실체)

* **생성 조건**: 상위 프로젝트에서 시스템을 최초로 정의하고 구현
* **특징**:
  * 시스템의 모든 내부 구조와 로직을 직접 제어 가능
  * Work, Call, ApiDef 등의 실행 상태를 실시간으로 관리
  * 독립적인 실행 환경과 상태 저장소 보유
* **저장 위치**: `runtime.sqlite3` 등 실행 환경

#### 2.2 Reference (간접 참조 객체)

* **생성 조건**: 하위 프로젝트에서 기존 Instance를 참조하여 활용
* **특징**:
  * 시스템의 인터페이스(ApiDef)만 접근 가능
  * 내부 Work 흐름이나 상태는 직접 수정 불가
  * ApiCall을 통한 간접 호출만 허용
* **구현 방법**: 기존 Instance의 GUID 또는 네트워크 주소 참조

### 3. 사용 예시

#### 3.1 프로젝트 계층 구조

```text
상위 프로젝트 A: RobotSystem (Instance 생성)
  ├─ Work: PickupSequence
  ├─ Work: PlaceSequence
  └─ ApiDef: StartPickup

하위 프로젝트 B: ConveyorSystem 
  └─ RobotSystem (Reference로 참조)
      └─ ApiCall → RobotSystem.StartPickup
```

#### 3.2 역할 차이

| 항목 | Instance (프로젝트 A) | Reference (프로젝트 B) |
|------|---------------------|----------------------|
| 내부 Work 접근 | ✅ 직접 수정 가능 | ❌ 접근 불가 |
| ApiDef 호출 | ✅ 내부에서 직접 실행 | ✅ ApiCall을 통한 간접 호출 |
| 상태 모니터링 | ✅ 실시간 상태 확인 | ❌ 응답 결과로만 유추 |
| 리소스 소유권 | ✅ 직접 소유/관리 | ❌ 참조만 가능 |

### 4. 이중성의 장점

#### 4.1 모듈 재사용성

* 한 번 정의된 시스템을 여러 프로젝트에서 Reference로 활용
* 중복 구현 없이 기능 공유 가능

#### 4.2 의존성 관리

* Instance는 독립적으로 개발/테스트 가능
* Reference는 인터페이스에만 의존하여 결합도 감소

#### 4.3 분산 시스템 구성

* Instance는 물리적으로 다른 장비에서 실행
* Reference는 네트워크를 통한 원격 호출 지원

### 5. 실행 흐름 예시

#### 5.1 Instance 직접 실행

```text
프로젝트 A 내부:
Start → RobotSystem.PickupSequence → Finish
```

#### 5.2 Reference 간접 호출

```text
프로젝트 B에서:
ConveyorWork → ApiCall → [네트워크] → 프로젝트 A.RobotSystem.ApiDef
```

### 6. 생성 및 참조 과정

#### 6.1 Instance 생성 과정

1. 상위 프로젝트에서 시스템 설계
2. Work, Call, ApiDef 구조 정의
3. 실행 환경에 Instance 등록
4. 고유 GUID 할당

#### 6.2 Reference 생성 과정

1. 하위 프로젝트에서 기존 Instance 검색
2. GUID 또는 네트워크 주소로 참조 설정
3. ApiDef 인터페이스 정보 가져오기
4. ApiCall 연결 구성

### 7. 주의사항

#### 7.1 순환 참조 방지

* 프로젝트 A가 B를 참조하고, B가 다시 A를 참조하는 상황 방지
* 명확한 계층 구조 유지 필요

#### 7.2 Version 호환성

* Instance 업데이트 시 Reference에서 호출하는 ApiDef 인터페이스 호환성 확인
* 버전 관리 체계 구축 필요

#### 7.3 네트워크 의존성

* Reference는 Instance의 가용성에 의존
* 네트워크 장애 시 대응 방안 필요

### 8. 상태 관리 매트릭스

| 구분 | Instance | Reference | 설명 |
|------|----------|-----------|------|
| 상태 저장 | ✅ 직접 관리 | ❌ 원격 의존 | Instance만 상태 소유 |
| 실행 제어 | ✅ 직접 제어 | ⚠️ 요청 기반 | Reference는 요청만 가능 |
| 디버깅 | ✅ 내부 추적 | ❌ 응답 로그만 | Instance에서만 상세 디버깅 |
| 리소스 사용 | 💾 메모리/CPU | 🌐 네트워크만 | 역할에 따른 리소스 차이 |

### 9. 설계 가이드라인

#### 9.1 Instance 설계 시

* 명확한 ApiDef 인터페이스 정의
* 상태 변화에 대한 로깅 체계 구축
* 동시 접근 제어 메커니즘 구현

#### 9.2 Reference 설계 시

* 네트워크 타임아웃 및 재시도 로직 구현
* Instance 상태 변화에 대한 polling 또는 callback 구조
* 오류 상황에 대한 fallback 전략 수립

### 10. 정리

**Instance ⊕ Reference 이중성**은 DS 시스템에서 **모듈 재사용성과 분산 시스템 구성**을 가능하게 하는 핵심 개념입니다.

* **Instance**: 시스템의 실제 구현체로서 독립적인 실행과 상태 관리
* **Reference**: 기존 Instance의 기능을 간접적으로 활용하는 참조 객체
* **이중성 효과**: 동일한 시스템이 프로젝트 관점에 따라 완전히 다른 역할 수행

이를 통해 복잡한 산업 자동화 환경에서 시스템 간 효율적인 협업과 자원 공유가 가능해집니다.



## DS Duality 이중성: Case 5 — WorkBit = Ready ⊕ Going ⊕ Finish ⊕ Homing

### 1. 개념 소개

DS 시스템에서 Work는 네 가지 상태(R, G, F, H)를 가지며, 이 상태는 단일 비트(WorkBit)와 외부 신호 조건에 따라 전이됩니다. WorkBit은 단순 플래그가 아니라, 실행 흐름 전체를 표현하는 핵심 FSM(Finite State Machine) 구조를 담고 있습니다.

* **Ready (R)**: 실행 준비 상태
* **Going (G)**: 작업 실행 중
* **Finish (F)**: 실행 완료됨
* **Homing (H)**: 초기화 진행 중

> ⊕: WorkBit는 하나의 비트로 네 가지 상태 전이를 표현하며, 외부 신호에 따라 의미가 동적으로 바뀜

### 2. 상태 전이 조건

```text
Ready ── Start 신호 ──▶ Going
Going ── 내부 작업 완료 ──▶ Finish
Finish ── Reset 신호 ──▶ Homing
Homing ── 초기화 완료 ──▶ Ready
```

#### 2.1 Ready → Going 전이

* **트리거 조건**: 외부 Start 신호 수신
* **동작 방식**: 이전 Work의 작업 완료 신호를 받아 실행 시작
* **특징**: 
  - 실행 준비가 완료된 상태에서만 Going으로 전이 가능
  - Start 신호는 외부 Arrow 조건에 의해 결정됨

#### 2.2 Going → Finish 전이

* **트리거 조건**: Work 내부 작업(Call 시퀀스) 완료
* **동작 방식**: 모든 내부 Call이 성공적으로 완료되면 자동 전이
* **특징**:
  - 내부 작업 진행 상황과 무관하게 완료 시점에서 즉시 전이
  - 외부 개입 없이 자율적으로 결정됨

#### 2.3 Finish → Homing 전이

* **트리거 조건**: 외부 Reset 신호 수신
* **동작 방식**: 작업 완료 후 초기화 명령을 받아 복귀 프로세스 시작
* **특징**:
  - Reset 신호는 외부 Arrow 조건에 의해 결정됨
  - 자동 복귀가 아닌 명시적 신호 기반 전이

#### 2.4 Homing → Ready 전이

* **트리거 조건**: 초기화 프로세스 완료
* **동작 방식**: 시스템 상태를 초기 조건으로 복원 후 자동 전이
* **특징**:
  - 내부 초기화 작업 완료 후 자율적 전이
  - 다음 작업 수행을 위한 준비 완료 상태로 복귀

### 3. 상태 전이 다이어그램

```text
    ┌─────────────────────────────────────┐
    │                                     │
    ▼                                     │
 Ready ──Start 신호──▶ Going ──완료──▶ Finish
    ▲                                     │
    │                                     │
    │                                     │Reset 신호
    │                                     │
    │                                     ▼
 Homing ◀────────── 초기화 완료 ──────── (Reset 실행)
```

### 4. 예시 흐름 시나리오

```text
시간:           0    1    2    3    4    5    6    7
Work 상태:      R    G    G    F    F    H    R    R
Start 신호:     0    1    0    0    0    0    0    0
Reset 신호:     0    0    0    0    1    0    0    0
내부 작업:      -    진행  완료  -    -    초기화 완료 -
```

**상세 설명:**
- **t=1**: Start 신호로 Ready → Going 전이
- **t=2**: Going 상태에서 내부 작업 진행
- **t=3**: 내부 작업 완료로 Going → Finish 전이
- **t=4**: Reset 신호로 Finish → Homing 전이  
- **t=5**: 초기화 진행 중
- **t=6**: 초기화 완료로 Homing → Ready 전이

### 5. 이중성 설명

* **단일 비트로 다중 상태 표현**: WorkBit 하나로 R/G/F/H 네 가지 상태 관리
* **내부 자율성과 외부 제어**: Going↔Finish는 내부 로직, Ready↔Going 및 Finish↔Homing은 외부 신호
* **순환 구조**: 네 상태가 순환하며 지속적인 작업 수행 가능

### 6. 설계 시 유의사항

#### 6.1 상태 전이 안정성
* Start와 Reset 신호가 동시에 활성화되지 않도록 신호 설계
* 각 상태 전이는 원자적(atomic)으로 처리되어 중간 상태 방지

#### 6.2 내부 작업 완료 조건
* Going 상태에서 Finish로의 전이 조건을 명확히 정의
* 내부 Call 시퀀스의 오류 처리 메커니즘 구축

### 7. 실제 적용 예시

#### 7.1 컨베이어 시스템
```text
Ready (대기) → Going (이송) → Finish (도착) → Homing (복귀) → Ready
```

#### 7.2 로봇 팔 동작
```text
Ready (대기) → Going (작업) → Finish (완료) → Homing (홈복귀) → Ready
```

### 8. 상태 관리 매트릭스

| 상태 | 진입 조건 | 종료 조건 | 제어 주체 | 특징 |
|------|----------|----------|----------|------|
| Ready | Homing 완료 | Start 신호 | 외부 | 실행 대기 상태 |
| Going | Start 신호 | 내부 작업 완료 | 내부 | 실행 중 |
| Finish | Going 완료 | Reset 신호 | 외부 | 완료 상태 |
| Homing | Reset 신호 | 초기화 완료 | 내부 | 복귀 프로세스 |

---






## DS Duality 이중성: Case 6 — φ(θ) = 위상 표현 ⊕ 상태 유추

### 1. 개념 소개

DS에서는 각 Work가 주어진 시점에서 고유한 상태를 갖습니다. 이 상태를 수치적으로 표현하기 위해, Work의 센서 입력 및 상태 조건을 기반으로 **위상(Phase) 값 φ(θ)** 를 계산합니다. 이는 시간 기반이 아닌 **상태 기반 위상 표현**으로, 각 Work의 현재 위치 또는 진행 상황을 수학적으로 정의하는 방식입니다.

* **θ (Theta)**: Work 내부 조건이나 센서 상태가 주어지는 시점 (불연속 상태 인덱스)
* **φ(θ)**: 해당 시점의 위상 값

> 위상은 상태 추정과 비교 판단을 위한 수치 지표로 사용됨

### 2. 위상 계산 공식

#### 2.1 Binary 기반 계산 (2진법)

$\phi_\theta = \frac{1}{2^n} \sum_{i=1}^{n} \left(2^{i-1} \cdot V_i \cdot C_{i,\theta}\right) \cdot 2\pi$

#### 2.2 Exponential 기반 계산 (지수 가중치)

$\phi_\theta = \frac{1}{e^n} \sum_{i=1}^{n} \left(e^{i-1} \cdot V_i \cdot C_{i,\theta}\right) \cdot 2\pi$

#### 2.3 Log 기반 정규화

$\phi_\theta = \ln \left(\sum_{i=1}^{n} e^{i-1} \cdot V_i \cdot C_{i,\theta}\right) \cdot \frac{2\pi}{n}$

* $V_i$: i번째 센서 값 또는 상태 비트
* $C_{i,\theta}$: 해당 시점 θ에서 조건 충족 여부 (0 or 1)

### 3. 활용 예시

#### 3.1 센서 입력에 따른 위상 결정

```text
Sensor A: ON (1)
Sensor B: OFF (0)
Sensor C: ON (1)
→ 위상 φ(θ) = 특정 각도로 계산됨
```

#### 3.2 동일한 φ(θ) 값 비교

* 서로 다른 시스템이 동일한 φ(θ)를 가질 경우 상태 동기화 판단 가능
* 일정 범위 내 유사한 φ(θ)는 유사 상태로 간주 가능

### 4. 이중성 설명

* **수치 표현 (Continuous)**: 상태를 단일 숫자 (위상)로 표현 가능
* **이산 상태 (Discrete)**: 실제 입력은 이진 조건 (0/1) 기반 → 상태 조합으로 위상 유도

### 5. 설계 시 고려사항

* 위상은 상태를 직접 조회할 수 없는 상황에서 추정 지표로 활용됨
* 센서 노이즈나 임계값 문제로 인한 위상 급변 주의
* 일정 φ(θ) 간 차이가 명확한 의미를 가질 수 있도록 조건 설계 필요

### 6. 실제 적용 시나리오

#### 6.1 디지털 트윈 상태 정렬

* 실제 설비와 시뮬레이션 시스템의 위상을 비교하여 동기화 상태 판단

#### 6.2 알람/오류 탐지

* φ(θ)의 급변 또는 역진행이 발생할 경우 이상 징후로 판단 가능

### 7. 정리

φ(θ) = 상태 기반 위상 표현 ⊕ 센서 조합 함수

* Work의 현재 상태를 수치적으로 비교 가능하게 하여 상태 추정 및 진단에 사용
* 센서나 내부 조건에 기반한 위상 함수 정의를 통해, Work 상태의 고유 지표로 활용됨
* 단순 상태값(R/G/F/H)을 넘어서, 비교와 예측 가능한 **상태 지표화 메커니즘** 제공











## DS Duality 이중성: Case 7 — Tag = SemanticLink ⊕ PhysicalBinding

### 1. 개념 소개

Tag는 DS 시스템에서 ApiCall과 ApiDef 간 데이터 교환을 가능하게 하는 매개체이며, 의미론적 연결과 물리적 바인딩의 이중적인 역할을 수행합니다. 이 Tag는 단순한 변수명이 아닌, 시스템 전체를 연결하는 핵심 연결점입니다.

* **SemanticLink (의미 연결)**: 기능적 의미에 따라 명명된 추상적 변수 (예: "StartSensor")
* **PhysicalBinding (물리적 매핑)**: 실제 디지털/아날로그 주소 또는 메모리 위치와 연결됨

> ⊕: 하나의 Tag는 의미와 물리 매핑을 동시에 가짐

### 2. 구성 요소 정의

#### 2.1 SemanticLink

* **정의**: 동작의 의미를 설명하는 이름
* **예시**: StartCommand, RobotArmReady, TempHighFlag
* **용도**:

  * 설계자와 사용자 간 의미 전달
  * 로직 문서화와 명세화

#### 2.2 PhysicalBinding

* **정의**: 실제 하드웨어 주소 혹은 내부 변수에 연결
* **예시**: X100, Y102, M300, DB100.DBX0.2
* **용도**:

  * I/O 연동, PLC 메모리 맵핑
  * 시뮬레이터 또는 물리 디바이스와 연결

### 3. 데이터 타입 분류

* **Digital (Bool)**: ON/OFF, True/False
* **Analog (Float, Int)**: 센서 수치, 온도 값 등
* **Enum (열거형)**: 상태 코드, 모드 구분 등

### 4. 구조 예시

```json
{
  "tagName": "StartSignal",
  "semantic": "Start",
  "binding": "X100",
  "type": "Digital"
}
```

* 이 Tag는 의미상 "Start" 명령이며, 실제로는 X100 입력을 바인딩함

### 5. 이중성 설명

* **설계 vs 실행**: 설계자 입장에서 Tag는 의미로 정의되지만, 런타임에서는 실제 바인딩 주소로 동작
* **추상 vs 구체**: 의미적 표현과 물리적 표현을 하나로 통합하여 시스템 해석과 구현을 동시에 만족시킴

### 6. 활용 예시

#### 6.1 ApiCall → ApiDef 간 데이터 전달

```text
ApiCall (출력) → Tag → ApiDef (입력)
```

* Tag는 호출자와 피호출자 간 인터페이스 역할

#### 6.2 시뮬레이션 및 디버깅

* 물리 바인딩이 없는 상태에서 의미 기반 테스트 가능
* 물리 주소가 없는 Virtual I/O 구성도 지원

### 7. 설계 시 고려사항

* 의미 이름 충돌 방지: 동일한 의미 이름은 프로젝트 내에서 고유해야 함
* 바인딩 주소 유효성 검증: 존재하지 않는 I/O 주소 연결 방지
* 복수 바인딩 방지: 하나의 Tag는 하나의 물리 위치에만 바인딩돼야 함

### 8. 정리

Tag = SemanticLink ⊕ PhysicalBinding 이중성은 DS 시스템 내 **모듈 간 데이터 연결, 하드웨어 연동, 시뮬레이션 환경 구성**에 핵심 역할을 하며, 추상화된 의미와 실제 시스템을 연결하는 중요한 다리 역할을 합니다.





## DS Duality 이중성: Case 8 — Arrow = Start ⊕ Reset

### 1. 개념 소개

Arrow는 DS 시스템 내에서 Work 간의 실행 흐름을 제어하는 신호선이며, **Start**와 **Reset** 두 가지 논리적 의미를 동시에 내포합니다. Arrow는 단순 연결선이 아니라 **조건부 신호 생성기**로서 작동하며, 상태 감지와 신호 전달을 통합한 동적 제어 구조입니다.

* **Start**: Finish 상태의 라이징 신호를 감지하여 Start 신호 출력
* **Reset**: Going 상태를 레벨 감지하여 Reset 신호 출력

> ⊕: 하나의 Arrow는 두 가지 감지 조건을 동시에 가지며, 각각 다른 신호를 생성함

### 2. Start와 Reset 신호 생성 조건

#### 2.1 Start 신호 (Finish 라이징 감지)

* **감지 조건**: 이전 Work가 Finish 상태로 전환되는 순간 (Rising Edge)
* **신호 생성**: Finish 상태 진입 시점에서 Start 신호 출력
* **대상**: 다음 Work의 Ready → Going 전이 트리거
* **특징**: 
  - 라이징 엣지 감지로 중복 트리거 방지
  - 일회성 신호로 정확한 타이밍 제어

#### 2.2 Reset 신호 (Going 하이레벨 감지)

* **감지 조건**: Work가 Going 상태를 유지하는 동안 (High Level)
* **신호 생성**: Going 상태가 지속되는 동안 Reset 신호 활성 상태 유지
* **대상**: 해당 Work의 Finish → Homing 전이 조건으로 사용
* **특징**:
  - 레벨 감지로 지속적인 신호 제공
  - Going 상태 종료 시 Reset 신호도 비활성화

### 3. 신호 타이밍 다이어그램

```text
Work A 상태:    R    G    G    F    F    F    F
Work B 상태:    R    R    R    G    G    F    H
Start 신호:     0    0    0    1    0    0    0  (A의 Finish↑)
Reset 신호:     0    0    0    1    1    0    0  (B의 Going 레벨)
```

### 4. Arrow 동작 메커니즘

#### 4.1 Finish 라이징 → Start 신호

```text
Work A: Ready → Going → Finish ↑ (Arrow가 감지)
                           ↓
Arrow: Start 신호 생성 ──▶ Work B: Ready → Going
```

#### 4.2 Going 레벨 → Reset 신호

```text
Work B: Ready → Going ■■■ (Arrow가 레벨 감지)
                  ↓
Arrow: Reset 신호 활성 ──▶ Work B: Finish → Homing 조건 제공
```

### 5. 이중성 설명

* **Start**: 이전 작업의 완료를 감지하여 연쇄 실행 트리거
* **Reset**: 현재 작업의 실행 상태를 감지하여 초기화 조건 제공
* **하나의 Arrow**에서 **두 가지 독립적인 신호 생성 로직**이 동시 작동

### 6. 신호 생성 조건 비교

| 신호 유형 | 감지 방식 | 감지 대상 | 신호 지속성 | 용도 |
|----------|----------|----------|-------------|------|
| Start | 라이징 엣지 | 이전 Work의 Finish | 순간 | 다음 Work 실행 트리거 |
| Reset | 하이 레벨 | 현재 Work의 Going | 지속적 | 현재 Work 초기화 조건 |

### 7. 주의사항 및 설계 가이드

#### 7.1 Finish 라이징 감지의 정확성

* Finish 상태가 지속되는 동안이 아닌, 전환 순간만 감지
* 다중 Work가 동일한 Finish 신호를 받지 않도록 Arrow 설계

#### 7.2 Going 레벨 감지의 안정성

* Going 상태 진입과 동시에 Reset 신호 활성화
* Going 상태 종료 시 Reset 신호도 즉시 비활성화

#### 7.3 순환 참조 방지

* Work A → Work B → Work A 형태의 순환에서 무한 루프 주의
* 종료 조건 또는 횟수 제한 로직 필요

### 8. 실제 적용 예시

#### 8.1 순차 작업 제어

```text
컨베이어 완료(Finish↑) → 로봇팔 시작(Start 신호)
로봇팔 실행(Going■) → 초기화 조건 활성(Reset 신호)
```

#### 8.2 병렬 작업 제어

```text
검사 완료(Finish↑) → 포장A, 포장B 동시 시작(Start 신호)
포장A 실행(Going■) → 포장A 초기화 조건(Reset 신호)
포장B 실행(Going■) → 포장B 초기화 조건(Reset 신호)
```

### 9. 신호 매트릭스

| Arrow 기능 | 입력 조건 | 출력 신호 | 대상 Work | 효과 |
|------------|----------|----------|----------|------|
| Start 생성 | 이전 Work Finish↑ | Start 신호 | 다음 Work | 실행 시작 |
| Reset 생성 | 현재 Work Going■ | Reset 신호 | 현재 Work | 초기화 조건 |

### 10. 정리

Arrow = Start ⊕ Reset 이중성은 DS의 실행 흐름 제어를 더욱 정교하고 예측 가능하게 구성하는 핵심 기제입니다.

**주요 특징:**
* **Start**: Finish 라이징 기반 연쇄 실행 트리거
* **Reset**: Going 레벨 기반 초기화 조건 제공
* **독립적 신호 생성**: 하나의 Arrow에서 두 종류의 신호를 독립적으로 생성
* **정확한 타이밍 제어**: 라이징 엣지와 레벨 감지의 조합으로 안정적 제어

이 구조를 통해 복잡한 산업 자동화 시스템에서도 예측 가능하고 안정적인 실행 흐름을 보장할 수 있습니다.
